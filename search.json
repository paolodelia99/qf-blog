[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I am Paolo D’Elia, a young professional working in the finance industry with a strong background in computer science and a passion for quantitative finance. I hold a Master’s degree in Computer Science from the University of Copenhagen, where I focused on probability theory, continuous-time finance, and machine learning applications in hedging strategies. My academic path has always been driven by the intersection of computing, mathematics, and financial markets.\nProfessionally, I have gained experience at Nordea Markets within the Quantitative Research team as a DevOps Engineer and currently work at Intesa Sanpaolo in the Proprietary Trading division as a Software Engineer. During my free time I contribute directly to QuantLib, the leading open-source C++ library in quantitative finance fixing issues and implementing new functionalities. I enjoy solving complex problems at the crossroads of software engineering and financial modeling, and I am eager to continue building innovative solutions that support trading, risk management, and research in modern finance."
  },
  {
    "objectID": "posts/post-with-code/exotic-book-vanna-volga.html",
    "href": "posts/post-with-code/exotic-book-vanna-volga.html",
    "title": "Hedging a book of exotic options using the Vanna-Volga method",
    "section": "",
    "text": "In this notebook, we continue to study the track of hedging in the world of FX options still from a trader sitting in a exotic desk in the S&T branch of a bank. As we’ve seen in the previous notebook (Hedging a book of exotics options) we have cover the basics on how to hedge a book of FX exotics, in this notebook we are going to take a further step to what is used in practice since, as you might know volatilities in practice are not flat across different strikes and across different time to expirations. Thus we are going to introduce a method that is going to take into account also for those volatilities as well to produce market consistent prices. This method is called the Vanna-Volga method.\nAgain as a library we are going to use QuantLib, because, well why not, right?"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-vanna-volga.html#market-data",
    "href": "posts/post-with-code/exotic-book-vanna-volga.html#market-data",
    "title": "Hedging a book of exotic options using the Vanna-Volga method",
    "section": "Market Data",
    "text": "Market Data\nLet’s assume that we are an USD based desk and we are dealing with EURUSD exotics. The initial market data at time \\(t = 0\\) is the following\n\\[\n\\begin{align*}\n    S_0 &= 1.18 \\\\\n    Date(Today) &= 16/09/2025 \\\\\n    T &= 0.5 \\text{ (time to expiration in years)} \\\\\n    r_d &= 0.045 \\\\\n    r_f &= 0.02 \\\\\n    \\sigma &= 0.13 \\\\\n\\end{align*}\n\\]\nLet’s further assume that in our book we have all options expirying in 6 months (thus \\(T = 0.5\\)).\n\nEUR_USD = 1.18\nspot_quote = ql.SimpleQuote(EUR_USD)\ntoday = ql.Date(16, ql.September, 2025)\nref_date = today\nr_d = 0.045\nr_f = 0.02\nvol_quote = ql.SimpleQuote(0.13)\nspot_handle = ql.QuoteHandle(spot_quote)\nvol_handle = ql.QuoteHandle(vol_quote)\n\ndc = ql.Actual365Fixed()\ncalendar = ql.JointCalendar(ql.Italy(), ql.UnitedStates(ql.UnitedStates.NYSE))\n\nexpiration_date = ref_date + ql.Period(6, ql.Months)\nexpiration_time = dc.yearFraction(ref_date, expiration_date)\ndomestic_rf_handle = ql.YieldTermStructureHandle(ql.FlatForward(today, r_d, dc))\nforeign_rf_handle = ql.YieldTermStructureHandle(ql.FlatForward(today, r_f, dc))\nblack_vol = ql.BlackConstantVol(today, ql.NullCalendar(), vol_handle, dc)\nvol_ts_handle = ql.BlackVolTermStructureHandle(black_vol)\n\nexp_time_quote = ql.SimpleQuote(expiration_time)\nexp_time_handle = ql.QuoteHandle(exp_time_quote)\nexp_time_sqrt_quote = ql.DerivedQuote(exp_time_handle, function=lambda x: np.sqrt(x))\nexp_time_sqrt_handle = ql.QuoteHandle(exp_time_sqrt_quote)\n\ndelta_type = ql.DeltaVolQuote.Spot\natm_type = ql.DeltaVolQuote.AtmSpot\natm_vol, delta25_call_vol, delta25_put_vol = 0.11, 0.125, 0.14\natm_vol_quote = ql.SimpleQuote(atm_vol)\ndelta25_call_vol_quote = ql.SimpleQuote(delta25_call_vol)\ndelta25_put_vol_quote = ql.SimpleQuote(delta25_put_vol)\n\n\n# Handle creations\nspot_handle = ql.QuoteHandle(spot_quote)\natm_vol_handle = ql.QuoteHandle(atm_vol_quote)\ndelta25_c_vol_handle = ql.QuoteHandle(delta25_call_vol_quote)\ndelta25_p_vol_handle = ql.QuoteHandle(delta25_put_vol_quote)\n\natm_dvol_quote = ql.DeltaVolQuote(atm_vol_handle, delta_type, expiration_time, atm_type)\ndelta25_c_dvol_quote = ql.DeltaVolQuote(0.25, delta25_c_vol_handle, expiration_time, delta_type)\ndelta25_p_dvol_quote = ql.DeltaVolQuote(-0.25, delta25_p_vol_handle, expiration_time, delta_type)\natm_dvol_handle = ql.DeltaVolQuoteHandle(atm_dvol_quote)\ndelta25_c_dvol_handle = ql.DeltaVolQuoteHandle(delta25_c_dvol_quote)\ndelta25_p_dvol_handle = ql.DeltaVolQuoteHandle(delta25_p_dvol_quote)\n\natm_std_handle = ql.QuoteHandle(ql.CompositeQuote(atm_vol_handle, exp_time_sqrt_handle, lambda x, y: x * y))\ndelta25_c_std_handle = ql.QuoteHandle(ql.CompositeQuote(delta25_c_vol_handle, exp_time_sqrt_handle, lambda x, y: x * y))\ndelta25_p_std_handle = ql.QuoteHandle(ql.CompositeQuote(delta25_p_vol_handle, exp_time_sqrt_handle, lambda x, y: x * y))\n\n# Setting the global evaluation date\nql.Settings.instance().evaluationDate = today\n\n\neur_dates = [ql.Date(27, ql.August, 2025), ql.Date(27, ql.August, 2026), ql.Date(27, ql.August, 2027)]\neur_dfs = [1.0, 0.98, 0.95]\neur_curve = ql.DiscountCurve(eur_dates, eur_dfs, dc)\neur_curve.enableExtrapolation()\neur_disc_ts = ql.YieldTermStructureHandle(eur_curve)\n\nusd_dates = [ql.Date(27, ql.August, 2025), ql.Date(27, ql.August, 2026), ql.Date(27, ql.August, 2027)]\nusd_dfs = [1.0, 0.985, 0.96]\nusd_curve = ql.DiscountCurve(usd_dates, usd_dfs, dc)\nusd_curve.enableExtrapolation()\nusd_disc_ts = ql.YieldTermStructureHandle(usd_curve)\n\nWe know, from empirical experience, that the volatilities across a specific time to expiration are not the same for all the strikes, this is due a number of different reasons: market demand dynamics, skewness of returns, the presence of jumps, …\nThus let’s define the smile for the barrier options expiring in 6 months, assuming that we know the values of the vols for the ATM, 25 \\(\\Delta\\) puts, and 25 \\(\\Delta\\) calls. To do that, QuantLib come in handy with ready classes to define a smile across different strikes with a fixed tenor.\nThe SmileSection class, is an object provided by the QuantLib library that represent a volatility smile for a specific tenor. QuantLib export some subclasses of SmileSection using different interpolation methods, thus you can choose some of them according to you needs.\n\ncall_barrier_factory = FxBarrierOptionFactory(spot_handle, ql.Option.Call)\nput_barrier_factory = FxBarrierOptionFactory(spot_handle, ql.Option.Put)\nput_vanilla_factory = FxVanillaOptionFactory(spot_handle, expiration_date, ql.Option.Put)\ncall_vanilla_factory = FxVanillaOptionFactory(spot_handle, expiration_date, ql.Option.Call)\ndelta_call_calc = ql.BlackDeltaCalculator(\n    ql.Option.Call, \n    ql.DeltaVolQuote.Spot, \n    EUR_USD, \n    eur_curve.discount(expiration_time), \n    usd_curve.discount(expiration_time), \n    np.sqrt(black_vol.blackVariance(expiration_time, EUR_USD)))\ndelta_put_calc = ql.BlackDeltaCalculator(\n    ql.Option.Put, \n    ql.DeltaVolQuote.Spot, \n    EUR_USD, \n    eur_curve.discount(expiration_time), \n    usd_curve.discount(expiration_time), \n    np.sqrt(black_vol.blackVariance(expiration_time, EUR_USD)))\n\n# Get the strikes equivalent for the 0.25 delta for call and put options\nd25_call_strike = delta_call_calc.strikeFromDelta(0.25)\nd25_put_strike = delta_put_calc.strikeFromDelta(-0.25)\natm_strike = delta_call_calc.atmStrike(ql.DeltaVolQuote.AtmDeltaNeutral)\n\n\n# Define the smile using a Spline Cubic interpolation\nsmile = ql.SplineCubicInterpolatedSmileSection(\n    expiration_time, \n    [d25_put_strike, atm_strike, d25_call_strike],\n    [delta25_p_std_handle, atm_std_handle, delta25_c_std_handle],\n    ql.makeQuoteHandle(atm_strike)\n)\n\ndef get_smile_vols(smile: ql.SmileSection, strikes: Union[np.array, List[float]]) -&gt; List[float]:\n    return [smile.volatility(s) for s in strikes]\n\n\nstrikes = np.arange(d25_put_strike - 0.01, d25_call_strike + 0.04, 0.01)\nsmile_vols = get_smile_vols(smile, strikes)\n\n\n\n\n\n\n\n\n\n\nAs mentioned above, the pricing method used in this notebook resembles what is acctually used in real life to be consistent with market prices. To take into account also for the smile a pricing method has been developed by Castagna and Mercurio (see Castagna and Mercurio 2007).\nThe Vanna-Volga method takes into account the volatility smile when pricing FX options by adjusting the BS price. It is based on the construction of a locally replicating portfolio whose associate hedging costs are added to the corresponding BS price so as to produce smile-consisent values.\nAssume that we construct our hedging portfolio with the following options: 25 \\(\\Delta\\) put, ATM call and 25 \\(\\Delta\\) call where the strikes are denoted by \\(K_i, i = 1, 2, 3 \\text{ and } K_1 &lt; K_2 &lt; K_3\\) and market implied volatilities are denoted by \\(\\sigma_i, i = 1, 2, 3\\). Using these options we can build a portfolio that zeros the partial derivatives up to the second order. In fact, denoting respectively by \\(\\Delta_t\\) and \\(x_i\\) the units of underlying assets and options with strikes \\(K_i\\) held at time \\(t\\) and selling \\(C_i^{BS}(t) = C^{BS}(t, K_i)\\) under diffusion dynamics both for \\(S_t\\) and \\(\\sigma = \\sigma_t\\), we have by Ito’s Lemma:\n\\[\n\\begin{align*}\nd C^{BS}(t, K) - \\Delta_t d S_t - \\sum_{i = 1}^3 x_i d C_i^{BS}(t)  & = [ \\frac{\\partial C^{BS}(t; K)}{\\partial t} - \\sum x_i \\frac{\\partial C_{i}^{BS}(t)}{\\partial t} ] dt + [ \\frac{\\partial C^{BS}(t; K)}{\\partial S} - \\Delta_t - \\sum x_i \\frac{\\partial C_{i}^{BS}(t)}{\\partial S} ] dS \\\\\n& + [ \\frac{\\partial C^{BS}(t; K)}{\\partial \\sigma} - \\sum x_i \\frac{\\partial C_{i}^{BS}(t)}{\\partial \\sigma} ] d \\sigma_t + \\frac{1}{2} [ \\frac{\\partial^2 C^{BS}(t; K)}{\\partial S^2} - \\sum x_i \\frac{\\partial^2 C_{i}^{BS}(t)}{\\partial S^2} ] (d S)^2 \\\\\n& + \\frac{1}{2} [ \\frac{\\partial^2 C^{BS}(t; K)}{\\partial \\sigma^2} - \\sum x_i \\frac{\\partial^2 C_{i}^{BS}(t)}{\\partial \\sigma^2} ] (d \\sigma)^2 + [ \\frac{\\partial^2 C^{BS}(t; K)}{\\partial S \\partial \\sigma } - \\sum x_i \\frac{\\partial^2 C_{i}^{BS}(t)}{\\partial S \\partial \\sigma } ] d S_t d \\sigma_t\n\\end{align*}\n\\]\nChoosing \\(\\Delta_t\\) and \\(x_i\\) so as to zero the coefficient of \\(dS_t, d\\sigma_t, (d\\sigma_t)^2, \\text{ and } dS_t d\\sigma_t\\), the whole portfolio (long position + hedges) is locally riskless at time \\(t\\), in what no stochastic terms are involved in its differential:\n\\[\n\\begin{align*}\nd C^{BS}(t; K) &- \\Delta_t dS_t - \\sum x_i d C_i^{BS}(t) = \\\\\n& = r^d [ C^{BS}(t; K) - \\Delta_t d S_t - \\sum x_i C_i^{BS}(t) ] dt \\quad (1)\n\\end{align*}\n\\]\nTo find the weight of the hedging portfolio we need to solve the following system\n\\[\n\\begin{equation*}\n\\left\\{\n\\begin{aligned}\n\\frac{\\partial C^{\\text{BS}}}{\\partial \\sigma} (K) &= \\sum_{i=1}^{3} x_i (K) \\frac{\\partial C^{\\text{BS}}}{\\partial \\sigma} (K_i) \\\\\n\\frac{\\partial^2 C^{\\text{BS}}}{\\partial \\sigma^2} (K) &= \\sum_{i=1}^{3} x_i (K) \\frac{\\partial^2 C^{\\text{BS}}}{\\partial \\sigma^2} (K_i) \\\\\n\\frac{\\partial^2 C^{\\text{BS}}}{\\partial \\sigma \\partial S_0} (K) &= \\sum_{i=1}^{3} x_i (K) \\frac{\\partial^2 C^{\\text{BS}}}{\\partial \\sigma \\partial S_0} (K_i)\n\\end{aligned}\n\\right.\n\\end{equation*}\n\\]\nNow, for the model to be useful it has to be consistent with market prices, thus the hedging costs at prevaling market prices has to be included in the option price to produce an arbitrage-free price taht is consistent with the quoted option prices \\(C^{MKT}(K_1), C^{MKT}(K_2) \\text{ and } C^{MKT}(K_3)\\). In case of a short maturity, i.e. for a small \\(T\\) equation \\((1)\\) can be approximated as\n\\[\n\\begin{align*}\n(S_T - K)^+ - C^{BS}(K) &- \\Delta_0 [ S_T - S_0 ] - \\sum x_i [ (S_T - K_i)^+ - C_i^{BS}(K_i) ] \\\\\n&\\approx r^d [ C^{BS}(K) - \\Delta_0 S_0 - \\sum x_i C_i^{BS}(K_i) ] T\n\\end{align*}\n\\]\nby adjusting the BS price with Market prices we have\n\\[\nC(K) = C^{BS}(K) + \\sum x_i(K) [ C^{MKT}(K_i) - C^{BS}(K_i) ] \\quad (2) \\\\[10pt]\n\\Downarrow \\\\[10pt]\nC^{BS}(K) = C(K) - \\sum x_i(K) [ C^{MKT}(K_i) - C^{BS}(K_i) ] \\\\[10pt]\n\\]\nsubstitute \\(C^{BS}(K)\\) yields to\n\\[\n\\begin{align*}\n(S_T - K)^+ - C(K) &+ \\sum x_i(K) [ C^{MKT}(K_i) - C^{BS}(K_i) ] - \\Delta_0 [ S_T - S_0 ] \\\\\n&- \\sum x_i [ (S_T - K_i)^+ - C^{BS}(K_i) ] \\\\\n&\\approx r^d [ C(K) - \\sum x_i(K) [ C^{MKT}(K_i) - C^{BS}(K_i) ] - \\Delta_0 S_0 - \\sum x_i C_i^{BS}(K_i) ]\n\\end{align*}\n\\]\nwhich can be simplified to\n\\[\n\\begin{align*}\n(S_T - K)^+ - C(K) &- \\Delta_0 [ S_T - S_0 ] - \\sum x_i [ (S_T - K_i)^+ - C^{BS}(K_i) - C^{MKT}(K_i) + C^{BS}(K_i) ] \\\\\n&\\approx r^d [ C(K) - \\Delta_0 S_0 - \\sum x_i C_i^{MKT}(K_i) ]\n\\end{align*}\n\\]\nby isolating \\((S_T - K)^+\\) we have then that\n\\[\n\\begin{align*}\n(S_T - K)^+ \\approx &\\overbrace{C(K)}^{\\text{VV price}} - \\overbrace{\\Delta_0 [S_T - S_0]}^{\\text{Delta Hedge}} + \\overbrace{\\sum_i x_i [ (S_T - K_i)^+ - C^{MKT}(K_i) ]}^{\\text{option positions}} \\\\\n&+ \\underbrace{r^d [ C(K) - \\Delta_0 S_0 - \\sum_i x_i C_i^{MKT}(K_i) ] T}_{\\text{residual bank account position}}\n\\end{align*}\n\\]\nThus from the above approximation, we are seening that the payoff of the option can still be replicated by shorting \\(\\Delta_0\\) units of the underlying asset, buying \\(x_i\\) options with strike \\(K_i\\) and investing the resulting cash at rate \\(r^d\\).\nThe quantity \\(C(K)\\) is defined as the VV option’s premium, implicitly assuming that the replication error is negligible for longer maturities. Such a premium is equal the BS price \\(C^{BS}(K)\\) plus the cost difference of the hedging portfolio induced by the market implied volatilities with respect to the constant volatility. Since we set \\(\\sigma_2 = \\sigma\\) using \\(\\sigma\\) the market volatility for strike \\(K_2\\), (2) can be simplified to:\n\\[\nC(K) = C^{BS}(K) + x_1 [ C^{MKT}(K_1) - C^{BS}(K_1) ] \\\\\n+ x_3 [ C^{MKT}(K_3) - C^{BS}(K_3) ]\n\\]\nThe model that extends the Black-Scholes model when dealing with FX options is the Garman-Kohlhagen model, whose dynamics have been defined above. Thus we need to create an instances of the Garman-Kohlhagen process in order to price FX vanilla options.\nFor the sake of simplicity we assume that all the options on the book have the same expiration, and again since we are under the Garman-Kohlhagen model the vol curve is flat, thus the vol across the different strikes is the same (unrealistic assumption). Here’s how the trader book is composed of:\n1st Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.30 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 1\nnotional = 1_000_000\nbarrier = 1.30\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_130b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbarrier_1 = BarrierPosition(barrier_25d_130b, notional, NullInstrument())\n\n2nd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$2000000 \\\\\n    \\text{Barrier} &= 1.08 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 2\nnotional = 2_000_000\nbarrier = 1.08\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_108b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbarrier_2 = BarrierPosition(barrier_25d_108b, notional, NullInstrument())\n\n3rd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.20 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and In}\n\\end{align*}\n\\]\n\n# Barrier 3\nnotional = 1_000_000\nbarrier = 1.20\nbarrier_type = ql.Barrier.UpIn\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_120b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbackup_vanilla = call_vanilla_factory.get_option(d25_call_strike)\nFxVanillaOptionFactory.assign_analyitcal_price_engine(backup_vanilla, process_25c)\nbarrier_3 = BarrierPosition(barrier_25d_120b, notional, backup_vanilla)\n\n4th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.05 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 4\nnotional = 1_000_000\nbarrier = 1.05\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_105b = put_barrier_factory.get_option(d25_put_strike, exercise, barrier, barrier_type)\nbarrier_4 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n5th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.25 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 5\nnotional = 2_000_000\nbarrier = 1.25\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_105b = put_barrier_factory.get_option(d25_put_strike, exercise, barrier, barrier_type)\nbarrier_5 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n\nbook: List[BarrierPosition] = [barrier_1, barrier_2, barrier_3, barrier_4, barrier_5]\n\nfor ins in book:\n    FxBarrierOptionFactory.assign_vanna_volga_price_engine(\n        ins.instrument, \n        atm_dvol_handle,\n        delta25_p_dvol_handle,\n        delta25_c_dvol_handle,\n        spot_handle,\n        usd_disc_ts,\n        eur_disc_ts\n    )\n\nThus the premium of the option will be the following\n\n\n[438.32143676364166,\n 23882.627384424337,\n 13961.757334147904,\n 403.5348985724314,\n 27478.97645781696]\n\n\nIn the Vanna-Volga case, since we don’t have a single vol but a smile, the sensitivities that we care about in the case of hedging are slightly different from the sensitivity that we look at in the Black-Scholes world. We already know how to calculte those sensitivities using finte differences from the previous notebook, what we care now is how the VV price is sensible to the various movements of the volatility smile, in particular we care about how the price will change in case of:\n\na parallel shift of the three volatilities;\na change in the difference between the two 25 \\(\\Delta\\) wings;\nan increase of the two wings with fixed ATM volatility\n\nIn this way we should be able to capture the effect of a parallel, a twist and a convexity movements of the implied volatility surface. Mathematically speaking using finite differences we can get those sensitivities in the following way:\n\nLevel\n\n\\[\n\\text{Level} \\approx \\frac{V(\\sigma_{ATM} + \\varepsilon, \\sigma_{25C} + \\varepsilon, \\sigma_{25P} + \\varepsilon) - V(\\sigma_{ATM} - \\varepsilon, \\sigma_{25C} - \\varepsilon, \\sigma_{25P} - \\varepsilon)}{2 \\varepsilon}\n\\]\n\nSkew Sensitivity\n\n\\[\n\\text{Skew} \\approx \\frac{V(\\sigma_{ATM}, \\sigma_{25C} + \\varepsilon / 2, \\sigma_{25P} - \\varepsilon / 2) - V(\\sigma_{ATM}, \\sigma_{25C} - \\varepsilon / 2, \\sigma_{25P} + \\varepsilon / 2)}{2 \\varepsilon}\n\\]\n\nCurvature\n\n\\[\n\\text{Curvature} \\approx \\frac{V(\\sigma_{ATM}, \\sigma_{25C} + \\varepsilon, \\sigma_{25P} + \\varepsilon) - V(\\sigma_{ATM}, \\sigma_{25C} - \\varepsilon , \\sigma_{25P} - \\varepsilon)}{2 \\varepsilon}\n\\]\n\ndef central_diff(instrument: ql.Instrument, h: float, quote: ql.SimpleQuote) -&gt; float:\n    u0 = quote.value()\n    quote.setValue(u0 + h)\n    P_Plus = instrument.NPV()\n    quote.setValue(u0 - h)\n    P_Minus = instrument.NPV()\n\n    quote.setValue(u0)\n    \n    return (P_Plus - P_Minus) / (2 * h)\n\ndef central_diff_2nd(instrument: ql.Instrument, h: float, quote: ql.SimpleQuote) -&gt; float:\n    u0 = quote.value()\n    P = instrument.NPV()\n    quote.setValue(u0 + h)\n    P_Plus = instrument.NPV()\n    quote.setValue(u0 - h)\n    P_Minus = instrument.NPV()\n\n    quote.setValue(u0)\n    \n    return (P_Plus - 2*P + P_Minus) / (h * h)\n\ndef cross_central_diff(instrument: ql.Instrument, h: float, k: float, quote_1: ql.SimpleQuote, quote_2: ql.SimpleQuote) -&gt; float:\n    u1_0 = quote_1.value()\n    u2_0 = quote_2.value()\n    \n    quote_1.setValue(u1_0 + h)\n    quote_2.setValue(u1_0 + k)\n    P_Plus_Plus = instrument.NPV()\n\n    quote_1.setValue(u1_0 + h)\n    quote_2.setValue(u1_0 - k)\n    P_Plus_Minus = instrument.NPV()\n\n    quote_1.setValue(u1_0 - h)\n    quote_2.setValue(u1_0 + k)\n    P_Minus_Plus = instrument.NPV()\n\n    quote_1.setValue(u1_0 - h)\n    quote_2.setValue(u1_0 - k)\n    P_Minus_Minus = instrument.NPV()\n\n    quote_1.setValue(u1_0)\n    quote_2.setValue(u2_0)\n    \n    return (P_Plus_Plus - P_Plus_Minus - P_Minus_Plus + P_Minus_Minus) / (4 * h * k)\n\ndef parallel_shift(instrument: ql.Instrument, quotes: List[ql.SimpleQuote], h: float):\n    u0s = [quote.value() for quote in quotes]\n\n    for quote, u0 in zip(quotes, u0s):\n        quote.setValue(u0 + h)\n    \n    P_Plus = instrument.NPV()\n\n    for quote, u0 in zip(quotes, u0s):\n        quote.setValue(u0 - h)\n    \n    P_Minus = instrument.NPV()\n\n    for quote, u0 in zip(quotes, u0s):\n        quote.setValue(u0)\n\n    return (P_Plus - P_Minus) / (2*h) \n\ndef skew_sensitivity(instrument: ql.Instrument, d25_c_quote: ql.SimpleQuote, d25_p_quote: ql.SimpleQuote, h: float) -&gt; float:\n    u1 = d25_c_quote.value()\n    u2 = d25_p_quote.value()\n\n    d25_c_quote.setValue(u1 + h / 2)\n    d25_p_quote.setValue(u2 - h / 2)\n\n    instrument.recalculate()\n    up_rr = instrument.NPV()\n\n    d25_c_quote.setValue(u1 - h / 2)\n    d25_p_quote.setValue(u2 + h / 2)\n\n    instrument.recalculate()\n    down_rr = instrument.NPV()\n\n    d25_c_quote.setValue(u1)\n    d25_p_quote.setValue(u2)\n\n    return (up_rr - down_rr) / (2 * h)\n\ndef curv_sensitivity(instrument: ql.Instrument, d25_c_quote: ql.SimpleQuote, d25_p_quote: ql.SimpleQuote, h: float) -&gt; float:\n    u1 = d25_c_quote.value()\n    u2 = d25_p_quote.value()\n\n    d25_c_quote.setValue(u1 + h)\n    d25_p_quote.setValue(u2 + h)\n\n    up_bf = instrument.NPV()\n\n    d25_c_quote.setValue(u1 - h)\n    d25_p_quote.setValue(u2 - h)\n\n    down_bf = instrument.NPV()\n\n    d25_c_quote.setValue(u1)\n    d25_p_quote.setValue(u2)\n\n    return (up_bf - down_bf) / (2 * h)\n\nThe plot below gives a visual clue on what those sensitivities measure:\n\n\n\n\n\n\n\n\n\nTo give you a more naive mathematical intuition, let’s assume that a vol smile is represented by the following 2nd order polynomial (a very likely assumption):\n\\[\n\\sigma(x) = a + b \\cdot x + c \\cdot x^2, \\text{ where } a, b, c \\in \\mathbb{R}\n\\]\n\nin the level sensitivity we are varying \\(a\\)\nwhen calculating the skew we are varying \\(b\\)\nwhile when calculating the curvature we are varying \\(c\\)\n\nSo we want to know how varying each of the function parameters effect the whole volatility smile, which in turns effected the option price.\n\ndelta = partial(central_diff, quote=spot_quote)\nvega = partial(central_diff, quote=atm_vol_quote)\ngamma = partial(central_diff_2nd, quote=spot_quote)\nvolga = partial(central_diff_2nd, quote=atm_vol_quote)\nvanna = partial(cross_central_diff, quote_1=spot_quote, quote_2=atm_vol_quote)"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-vanna-volga.html#hedging-the-book",
    "href": "posts/post-with-code/exotic-book-vanna-volga.html#hedging-the-book",
    "title": "Hedging a book of exotic options using the Vanna-Volga method",
    "section": "Hedging the book",
    "text": "Hedging the book\nAs explained in the Hedging a book of exotics options, we want to keep low exposure also to the other high order greeks, but since we don’t have a single vol but smile for a specific tenor we want to hedge ourselves from the possible movements of that smile as described above.\n\nHedge methodology\nLet our exposure vector be:\n\\[\n\\mathbf{E} = \\begin{bmatrix} \\Delta \\\\ \\text{Level} \\\\ \\text{Skew} \\\\ \\text{Curvature}  \\end{bmatrix}.\n\\]\nand let our hedge matrix be:\n\\[\nH = \\left[\n\\begin{array}{c|cccc}\n    & \\text{Spot} & \\text{Straddle} & \\text{RR} & \\text{Butterfly} \\\\\n    \\hline\n    \\Delta   & h_{11} & h_{12} & h_{13} & h_{14} \\\\\n    \\text{Level}   & h_{21} & h_{22} & h_{23} & h_{24} \\\\\n    \\text{Skew}  & h_{31} & h_{32} & h_{33} & h_{34} \\\\\n    \\text{Curvature}  & h_{41} & h_{42} & h_{43} & h_{44} \\\\\n\\end{array}\n\\right]\n\\]\nThen we can solve the following linear system and find the weights \\(x\\) (position sizes) just by:\n\\[\nx = H^{-1} E\n\\]\nWhen we want to calculate the greeks of our portfolio, we want to do it in meaningful way, thus this requires to us to set the shift operator in a way that makes sense to measure the specific risk of our porfolio. The two main ways that industry professional do that is by using 1% of the spot change and 1% vol change.\n\nspot_change = 0.01 * spot_quote.value() / 2\nvol_change = 0.01\nquotes = [atm_vol_quote, delta25_call_vol_quote, delta25_put_vol_quote]\n\ndelta_book = sum([pos.sensitivity(partial(central_diff, quote=spot_quote), h=spot_change) for pos in book])\nlevel_book = sum([pos.sensitivity(partial(parallel_shift, quotes=quotes), h=vol_change) for pos in book])\nskew_book = sum([pos.sensitivity(partial(skew_sensitivity, \n                                         d25_c_quote=delta25_call_vol_quote,\n                                         d25_p_quote=delta25_put_vol_quote), h=vol_change) for pos in book])\ncurv_book = sum([pos.sensitivity(partial(curv_sensitivity, \n                                         d25_c_quote=delta25_call_vol_quote,\n                                         d25_p_quote=delta25_put_vol_quote), h=vol_change) for pos in book])\n\nThe raw Greek exposition for our book is then the following:\n\n\nBook Delta exposure: -115632.67827744933\nBook Level exposure: 718295.615419507\nBook Skew exposure: 137760.4070661429\nBook Curvature Call exposure: 417234.2386220757\n\n\nTo get a more meaningful value of the sensitivities needed for the trader’s perspective, we need to multiply the \\(\\Delta\\) by the spot value and the smile sensitivities by the \\(\\%\\) of vol that we’ve used to measure those sensitivities (thus in our case by \\(1\\%\\)).\n\n\nBook Delta exposure: $-136446.5603673902\nResidual Level exposure: $7182.956154195071\nResidual Skew exposure: $1377.6040706614292\nResidual Curvature exposure: $4172.342386220757\n\n\nOur exposure vector \\(E = [ \\Delta, \\text{Level}, \\text{Skew}, \\text{Curvature} ]\\) is:\n\n# Greek exposure vector\nE = np.array([delta_book, level_book, skew_book, curv_book])\nE\n\narray([-115632.67827745,  718295.61541951,  137760.40706614,\n        417234.23862208])\n\n\nFor each of the base instrument (Spot, ATM call, ATM put, \\(25\\Delta\\) call and \\(25\\Delta\\) put) let’s calculate the basic greeks.\n\n# hedge_matrix\nbase_notional = np.float64(1_000_000)\nspot_greeks = np.array([1, 0, 0, 0]) * base_notional\natm_call_greeks = np.array([\n    central_diff(atm_call, h=spot_change, quote=spot_quote), # Delta\n    parallel_shift(atm_call, quotes, h=vol_change), # Level\n    skew_sensitivity(atm_call,  # Skew\n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(atm_call, # Curvature\n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\natm_put_greeks = np.array([\n    delta(atm_put, h=spot_change),\n    parallel_shift(atm_put, quotes, h=vol_change),\n    skew_sensitivity(atm_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(atm_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\ndelta25_call_greeks = np.array([\n    delta(delta25_call, h=spot_change),\n    parallel_shift(delta25_call, quotes, h=vol_change),\n    skew_sensitivity(delta25_call, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(delta25_call, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\ndelta25_put_greeks = np.array([\n    delta(delta25_put, h=spot_change),\n    parallel_shift(delta25_put, quotes, h=vol_change),\n    skew_sensitivity(delta25_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(delta25_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\n\n# Let's create the straddle, RR, Butterfly from the base vanilla options\natm_straddle = atm_call_greeks + atm_put_greeks\nrr = delta25_call_greeks - delta25_put_greeks\nbutterfly = delta25_call_greeks + delta25_put_greeks - 2 * atm_straddle\n\n# Hedge Matrix\nH = np.stack([spot_greeks, atm_straddle, rr, butterfly]).T\n\nSince our system the number of equations is the same as the number of variables, thus can find the optiomal solution of the system by using np.linalg.solve\n\nx = np.linalg.solve(H, E)\n\nNow that we have a solution let’s see what’s our remaining exposure to each of the choosen hedged greeks. We do that by\n\\[\nH x - E\n\\]\n\nresidual_greeks = (H @ x - E).tolist()\n\nprint(f\"Residual Delta exposure: ${residual_greeks[0] * spot_quote.value()}\")\nprint(f\"Residual Level exposure: ${residual_greeks[1] * 0.01}\")\nprint(f\"Residual Skew exposure: ${residual_greeks[2] * 0.01}\")\nprint(f\"Residual Curvature exposure: ${residual_greeks[3] * 0.01}\")\n\nResidual Delta exposure: $0.0\nResidual Level exposure: $1.1641532182693482e-12\nResidual Skew exposure: $0.0\nResidual Curvature exposure: $0.0\n\n\nAnother crucial thing when hedging a book is, of course, to measure the P&L from one rebalancing period to another. Let’s then calculate the value of the various components of our hedging portfolio. We have the the P&L from time \\(t\\) is calculated as:\n\\[\nP\\&L_{t \\rightarrow t + 1} = (V_{t + 1}^{book} + V_{t + 1}^{hedge} + C_{t + 1}) - (V_{t}^{book} + V_{t}^{hedge} + C_{t})\n\\]\nwhere:\n\n\\(V_{t}^{book}\\) is the value of our book at time \\(t\\), which is the sum of the premiums that we’ve been collected\n\\(V_{t}^{hedge}\\) is the value of the hedging portfolio, the sum of the premium of the structures that we have bought to hedge our from the various sensistivies\n\\(C_t\\) the cash/bank account of our portfolio which includes financing of cash and trade cashflows\n\nA shorter way to express the P&L, is just by considering the variation of the value of the book + the variation of the value of the hedges + cost of borrowing + interest accrued:\n\\[\nP\\&L_{t \\rightarrow t + 1} = \\delta V_{t, t + 1}^{book} + \\delta V_{t, t + 1}^{hedge} + \\text{cost of borrowing} + \\text{interest accrued}\n\\]\nsince the rebalancing of the hedges of the bank account happend at the end of trading day.\n\nspot_premium_eur = x[0] * base_notional\nspot_premium_usd = x[0] * base_notional * spot_quote.value()\natm_straddle_premium = atm_call.NPV() + atm_put.NPV() * base_notional * x[1]\nrr_premium = delta25_call.NPV() - delta25_put.NPV() * base_notional * x[2]\nbutterfly_premium = (delta25_call.NPV() + delta25_put.NPV() - 2 * (atm_call.NPV() + atm_put.NPV())) * x[3] * base_notional\n\nThe usd borrowed (which is the sum of the premiums of or hedging instrument) is crucial for use to calculate the interest accrued for borrowing the usd dollars to buy the hedging structures.\n\nhedging_str_premium = atm_straddle_premium + rr_premium + butterfly_premium + spot_premium_usd\nhedging_str_premium\n\nnp.float64(-543905.6415990698)\n\n\nThus the value of the cash at time \\(t = 0\\) is the equal to all the cash that we’ve borrowed to build the hedging structures plus the premiums that we’ve been collected from selling the exotics options\n\nbank_account_value = - hedging_str_premium + np.sum(premiums)\nbank_account_value\n\nnp.float64(610070.8591107951)\n\n\n\nport_value = [hedging_str_premium - np.sum(premiums) + bank_account_value]\n\nprint(f\"The portfolio value at time t = 0 is {port_value[0]}\")\n\nThe portfolio value at time t = 0 is 0.0"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-vanna-volga.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "href": "posts/post-with-code/exotic-book-vanna-volga.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "title": "Hedging a book of exotic options using the Vanna-Volga method",
    "section": "Changes of the hedging portfolio with the changes of the market conditions",
    "text": "Changes of the hedging portfolio with the changes of the market conditions\nNow that we have setup our hedging portfolio, let’s verify how it will change as the spot and vol smile change. Let’s assume that in a week period the spot went go down by 300 pips, the ATM vol went up by \\(0.5\\%\\) while the the 25 \\(\\Delta\\) Put vol went up \\(0.8\\%\\) (since the price to hedge from downside has went up because of the underlying so there is more demand for puts).\n\nref_date = today + ql.Period(7, ql.Days)\nexpiration_time = dc.yearFraction(ref_date, expiration_date)\nexp_time_quote.setValue(expiration_time)\n\nspot_quote.setValue(1.15)\natm_vol_quote.setValue(atm_vol + 0.005)\ndelta25_put_vol_quote.setValue(delta25_put_vol + 0.008)\n\nnew_d25_call_strike = delta_call_calc.strikeFromDelta(0.25)\nnew_d25_put_strike = delta_put_calc.strikeFromDelta(-0.25)\nnew_atm_strike = delta_call_calc.atmStrike(ql.DeltaVolQuote.AtmDeltaNeutral)\n\nnew_smile = ql.SplineCubicInterpolatedSmileSection(\n    expiration_time, \n    [new_d25_put_strike, new_atm_strike, new_d25_call_strike],\n    [delta25_p_std_handle, atm_std_handle, delta25_c_std_handle],\n    atm_vol_handle\n)\n\n# Move vols and expiry time\nql.Settings.instance().evaluationDate = ref_date\n\nHere’s how the new smile looks like compared to the old the smile:\n\n\n\n\n\n\n\n\n\n\nnew_premiums = [pos.NPV() for pos in book]\n\nWith the new spot and vols let’s recalculate the book exposure\n\ndelta_book = sum([pos.sensitivity(partial(central_diff, quote=spot_quote), h=spot_change) for pos in book])\nlevel_book = sum([pos.sensitivity(partial(parallel_shift, quotes=quotes), h=vol_change) for pos in book])\nskew_book = sum([pos.sensitivity(partial(skew_sensitivity, \n                                         d25_c_quote=delta25_call_vol_quote,\n                                         d25_p_quote=delta25_put_vol_quote), h=vol_change) for pos in book])\ncurv_book = sum([pos.sensitivity(partial(curv_sensitivity, \n                                         d25_c_quote=delta25_call_vol_quote,\n                                         d25_p_quote=delta25_put_vol_quote), h=vol_change) for pos in book])\n\n# new Exposure vector\nE = np.array([delta_book, level_book, skew_book, curv_book])\n\n\n\nBook Delta exposure: $-426252.06994998624\nResidual Level exposure: $6494.259093454982\nResidual Skew exposure: $1365.6531019809127\nResidual Curvature exposure: $5016.983190482754\n\n\nAs before let’s recalculate the greeks for the basic trading instruments, and then combine to obtain the greeks for the structures used in the hedging portfolio.\n\n# hedge_matrix\nbase_notional = np.float64(1_000_000)\nspot_greeks = np.array([1, 0, 0, 0]) * base_notional\natm_call_greeks = np.array([\n    central_diff(atm_call, h=spot_change, quote=spot_quote), # Delta\n    parallel_shift(atm_call, quotes, h=vol_change), # Level\n    skew_sensitivity(atm_call,  # Skew\n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(atm_call, # Curvature\n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\natm_put_greeks = np.array([\n    delta(atm_put, h=spot_change),\n    parallel_shift(atm_put, quotes, h=vol_change),\n    skew_sensitivity(atm_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(atm_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\ndelta25_call_greeks = np.array([\n    delta(delta25_call, h=spot_change),\n    parallel_shift(delta25_call, quotes, h=vol_change),\n    skew_sensitivity(delta25_call, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(delta25_call, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\ndelta25_put_greeks = np.array([\n    delta(delta25_put, h=spot_change),\n    parallel_shift(delta25_put, quotes, h=vol_change),\n    skew_sensitivity(delta25_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change),\n    curv_sensitivity(delta25_put, \n                     d25_c_quote=delta25_call_vol_quote, \n                     d25_p_quote=delta25_put_vol_quote,\n                     h=vol_change)\n]) * base_notional\n\n\n# Let's create the straddle, RR, Butterfly from the base vanilla options\natm_straddle = atm_call_greeks + atm_put_greeks\nrr = delta25_call_greeks - delta25_put_greeks\nbutterfly = delta25_call_greeks + delta25_put_greeks - 2 * atm_straddle\n\n# Hedge Matrix\nH = np.stack([spot_greeks, atm_straddle, rr, butterfly]).T\n\nThe esposure of our hedging portfolio is now is:\n\n# New exposure of the hedging portfolio\nexposure = (H @ x - E).tolist()\n\nprint(f\"Residual Delta exposure: ${exposure[0] * spot_quote.value()}\")\nprint(f\"Residual Level exposure: ${exposure[1] * 0.01}\")\nprint(f\"Residual Skew exposure: ${exposure[2] * 0.01}\")\nprint(f\"Residual Curvature exposure: ${exposure[3] * 0.01 * spot_quote.value()}\")\n\nResidual Delta exposure: $2738.4458590258755\nResidual Level exposure: $-67.84857193228905\nResidual Skew exposure: $-411.47083519745325\nResidual Curvature exposure: $-1701.7232883233276\n\n\nTo calculate the \\(\\text{P\\&L}\\) from time \\(t\\) to \\(t+1\\) we need to calculate the change of the value of the hedging portfolio as well\n\nspot_premium_usd = x[0] * base_notional * spot_quote.value()\natm_straddle_premium = atm_call.NPV() + atm_put.NPV() * base_notional * x[1]\nrr_premium = delta25_call.NPV() - delta25_put.NPV() * base_notional * x[2]\nbutterfly_premium = (delta25_call.NPV() + delta25_put.NPV() - 2 * (atm_call.NPV() + atm_put.NPV())) * x[3] * base_notional\nnew_hedging_str_premium = atm_straddle_premium + rr_premium + butterfly_premium + spot_premium_usd\n\n\ndt = dc.yearFraction(today, today + ql.Period(7, ql.Days))\nusd_interest_cost = hedging_str_premium * r_d * dt\neur_interest_accr = spot_premium_eur * r_f * dt\nnew_total_portfolio_value = new_hedging_str_premium - np.sum(new_premiums) + bank_account_value - usd_interest_cost + eur_interest_accr * spot_quote.value()\n\nprint(f\"Portfolio value at time t = 1 is: ${new_total_portfolio_value}\")\n\nPortfolio value at time t = 1 is: $30021.90322561409\n\n\n\n\nThe P&L after a week is: $30021.90322561409\n\n\nIf we want to reduce our exposure and bring it back to a lower one, we need to recalculate the optimal hedging weights for our hedging portfolio as before:\n\nx_new = np.linalg.solve(H, E)\n\nThis how our hedging portfolio has to change:\n\n(x_new - x) * base_notional\n\narray([-101803.29731514,  418687.61215821,  208353.40317859,\n        322112.47789261])\n\n\nThe residual greek exposure after the rebalancing is:\n\n\nResidual Delta exposure: $1.3387762010097503e-10\nResidual Level exposure: $0.0\nResidual Skew exposure: $0.0\nResidual Curvature exposure: $0.0"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quant Finance’s posts",
    "section": "",
    "text": "Hedging a book of exotic options with different maturities\n\n\n\nQuantitative finance\n\nHedging\n\nExotic options\n\n\n\n\n\n\n\n\n\nFeb 11, 2026\n\n\n\n\n\n\n\n\n\n\n\n\nHedging a book of exotic options using the Vanna-Volga method\n\n\n\nQuantitative finance\n\nHedging\n\nExotic options\n\n\n\n\n\n\n\n\n\nJan 24, 2026\n\n\n\n\n\n\n\n\n\n\n\n\nHedging a book of exotic options\n\n\n\nQuantitative finance\n\nHedging\n\nExotic options\n\n\n\n\n\n\n\n\n\nSep 27, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-local-vol.html",
    "href": "posts/post-with-code/exotic-book-local-vol.html",
    "title": "Hedging a book of exotic options with different maturities",
    "section": "",
    "text": "In this notebook, we continue on the track to study the track of hedging in the world of FX option still from a trader sitting in a exotic desk in a investment bank. As we’ve seen in the previous notebooks (Hedging a book of exotics options) we have cover the basics on how to hedge a book of FX exotics, both in the case where we are hedging under the Black-Scholes model and in the case where we have a volatility smile and hedge options with the same expiration using the VV method (Hedging a book of exotics options using the Vanna-Volga), in this notebook we are going to take a even further step since we are going to leverage the whole IV surface to hedge our portfolio made of different options with different strikes and expirations. In this case, I’ve decided to leverage the local volatility model and price using the Finite Difference method. The assets that we are considering are thus under the following dynamics:\n\\[\n\\begin{align*}\ndS_t &= (r_d - r_f) S_t \\, dt + \\sigma(S, t) S_t \\, dW_t^d, \\\\\ndB^d_t &= r_d B^d_t\\, dt, \\\\\ndB^f_t &= r_f B^f_t\\, dt\n\\end{align*}\n\\]"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-local-vol.html#exotics-book",
    "href": "posts/post-with-code/exotic-book-local-vol.html#exotics-book",
    "title": "Hedging a book of exotic options with different maturities",
    "section": "Exotics Book",
    "text": "Exotics Book\nHere’s how the trader book is composed of:\n1st Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    T &= 1.0 \\\\\n    \\text{Barrier} &= 1.30 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 1\nnotional = 1_000_000\nbarrier = 1.30\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(maturity_1y)\nstrike = strike_from_delta(\n    EUR_USD,\n    0.25,\n    times[-1],\n    ql.Option.Call,\n    ivs[-1, -2],\n    usd_curve,\n    eur_curve\n)\n\nbarrier_25d_130b = call_barrier_factory.get_option(strike, exercise, barrier, barrier_type)\nbarrier_1 = BarrierPosition(barrier_25d_130b, notional, NullInstrument())\n\n2nd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$2000000 \\\\\n    T &= 0.5 \\\\\n    \\text{Barrier} &= 1.08 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 2\nnotional = 2_000_000\nbarrier = 1.08\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(maturity_6m)\nstrike = strike_from_delta(\n    EUR_USD,\n    0.25,\n    dc.yearFraction(today, maturity_6m),\n    ql.Option.Call,\n    0.09, # Interpolated value\n    usd_curve,\n    eur_curve\n)\n\nbarrier_25d_108b = call_barrier_factory.get_option(strike, exercise, barrier, barrier_type)\nbarrier_2 = BarrierPosition(barrier_25d_108b, notional, NullInstrument())\n\n3rd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    T &= 0.25 \\\\\n    \\text{Barrier} &= 1.20 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and In}\n\\end{align*}\n\\]\n\n# Barrier 3\nnotional = 1_000_000\nbarrier = 1.20\nbarrier_type = ql.Barrier.UpIn\nexercise = ql.EuropeanExercise(maturity_3m)\nstrike = strike_from_delta(\n    EUR_USD,\n    0.25,\n    dc.yearFraction(today, maturity_3m),\n    ql.Option.Call,\n    ivs[-2, -2],\n    usd_curve,\n    eur_curve\n)\ncall_vanilla_factory = FxVanillaOptionFactory(spot_handle, maturity_1y, ql.Option.Call)\n\nbarrier_25d_120b = call_barrier_factory.get_option(strike, exercise, barrier, barrier_type)\nbackup_vanilla = call_vanilla_factory.get_option(strike)\nFxVanillaOptionFactory.assign_analyitcal_price_engine(backup_vanilla, process_25c)\nbarrier_3 = BarrierPosition(barrier_25d_120b, notional, backup_vanilla)\n\n4th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    T &= 0.25 \\\\\n    \\text{Barrier} &= 1.05 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 4\nnotional = 1_000_000\nbarrier = 1.05\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(maturity_3m)\nstrike = strike_from_delta(\n    EUR_USD,\n    -0.25,\n    dc.yearFraction(today, maturity_3m),\n    ql.Option.Put,\n    ivs[-2, 2],\n    usd_curve,\n    eur_curve\n)\n\nbarrier_25d_105b = put_barrier_factory.get_option(strike, exercise, barrier, barrier_type)\nbarrier_4 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n5th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.25 \\\\\n    T &= 0.0833 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 5\nnotional = 2_000_000\nbarrier = 1.25\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(maturity_1m)\nstrike = strike_from_delta(\n    EUR_USD,\n    -0.25,\n    dc.yearFraction(today, maturity_1m),\n    ql.Option.Put,\n    ivs[1, 2],\n    usd_curve,\n    eur_curve\n)\n\nbarrier_25d_105b = put_barrier_factory.get_option(strike, exercise, barrier, barrier_type)\nbarrier_5 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n\nbook: List[BarrierPosition] = [barrier_1, barrier_2, barrier_3, barrier_4, barrier_5]\n\nfor ins in book:\n    FxBarrierOptionFactory.assign_price_engine(ins.instrument, engine)\n\nNow we have setup our book, let’s see what’s the premium on those options.\n\n\nBarrier 1, price $260.39\nBarrier 2, price $26721.44\nBarrier 3, price $7822.55\nBarrier 4, price $4510.61\nBarrier 5, price $13603.77\n\n\n\n\nThe total book value is ${book_value}"
  },
  {
    "objectID": "posts/post-with-code/exotic-book-local-vol.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "href": "posts/post-with-code/exotic-book-local-vol.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "title": "Hedging a book of exotic options with different maturities",
    "section": "Changes of the hedging portfolio with the changes of the market conditions",
    "text": "Changes of the hedging portfolio with the changes of the market conditions\nNow that we have setup our hedging portfolio see verify how its will change as the spot and vol surface change. Let’s assume that in a 2-day period the spot went go down by 200 pips, the ATM vol went up by \\(0.5\\%\\) while the the 25 \\(\\Delta\\) Put vol went up \\(0.8\\%\\) (since the price to hedge from downside has went up because of the underlying so there is more demand for puts).\n\\[\n\\begin{align*}\n    S_0 &= 1.16 \\\\\n    Date(Today) &= 16/12/2025 \\\\\n    r_d &= 0.03 \\\\\n    r_f &= 0.02 \\\\\n\\end{align*}\n\\]\nWith the following Implied Vol surface\n\n\n\n\n\\(10\\Delta p\\)\n\\(25\\Delta p\\)\nATM\n\\(25\\Delta c\\)\n\\(10\\Delta c\\)\n\n\n\n\n3D\n14.00%\n13.00%\n12.00%\n11.50%\n10.50%\n\n\n1M\n14.00%\n13.50%\n10.00%\n9.00%\n9.75%\n\n\n3M\n12.75%\n11.50%\n10.00%\n9.00%\n9.50%\n\n\n1Y\n12.50%\n10.75%\n10.25%\n9.75%\n9.50%\n\n\n\nWe are now interested to see what’s the new exposure of our hedging portfolio.\n\nref_date = today + ql.Period(2, ql.Days)\n\nspot_quote.setValue(1.16)\n\nnew_times = [dc.yearFraction(ref_date, m) for m in maturities]\n# Vol surface\nnew_ivs = np.array([\n    # 0.10P, 0.25P, ATM,  0.25C, 0.10C\n    [0.140, 0.13,  0.12, 0.115, 0.105],  # 1W \n    [0.140, 0.135, 0.110, 0.105, 0.10],  # 1M\n    [0.1275, 0.115, 0.100, 0.090, 0.095],  # 3M\n    [0.125, 0.1075, 0.1025, 0.0975, 0.105],  # 1Y\n])\n\n# Move vols and expiry time\nql.Settings.instance().evaluationDate = ref_date\n\nLet’s calculate the new strikes needed to build the new calibrated local vol surface.\n\nnew_strikes = create_strike_iv_surf(spot_quote.value(), usd_curve, eur_curve, deltas, option_types, new_times, new_ivs)\n\n\n\narray([[1.13612881, 1.14837208, 1.16019107, 1.17076404, 1.17858337],\n       [1.10412947, 1.13192316, 1.16097287, 1.18435339, 1.20361041],\n       [1.07412444, 1.11998689, 1.16256386, 1.19758045, 1.23419363],\n       [1.00256954, 1.09219685, 1.16972097, 1.24936665, 1.33944933]])\n\n\n\nah_vol_surf, ah_local_vol = calibrate_vol_surface(new_strikes, option_types, maturities, new_ivs)\nblack_vol_surf_handle.linkTo(ah_vol_surf)\nlocal_vol_surf_handle.linkTo(ah_local_vol)\n\n\n\n\n\n\n\n\n\n\nWe now have to recalculate the price of the hedging vanillas and the value of the new exotics to calculate the \\(P\\&L\\) from time \\(t\\) to time \\(t+1\\)\n\nfor i in range(len(vanilla_options)):\n    for j in range(len(vanilla_options[0])):\n        process = ql.GarmanKohlagenProcess(\n            spot_handle,\n            foreign_ts,\n            domestic_ts,\n            ql.BlackVolTermStructureHandle(\n                ql.BlackConstantVol(ref_date, calendar, new_ivs[i, j], dc)\n            )\n        )\n        vanilla_options[i][j].setPricingEngine(ql.AnalyticEuropeanEngine(process))\n\n\nnew_premiums = [opt.NPV() for opt in book]\nnew_book_value = sum(new_premiums)\nnew_vanilla_premiums = [[opt.NPV() * v_w * notional for opt, v_w in zip(row, v_row)] for row, v_row in zip(vanilla_options, vega_weights)]\nspot_premium_eur = hedging_delta_weight * notional \nnew_spot_hedge_usd = hedging_delta_weight * notional * spot_handle.value()\nnew_hedging_str_premium = np.sum(new_vanilla_premiums) + new_spot_hedge_usd\n\n\ndt = dc.yearFraction(today, ref_date)\nusd_interest_cost = hedging_str_premium * r_d * dt\neur_interest_accr = spot_premium_eur * r_f * dt\n\n\nnew_total_portfolio_value = new_hedging_str_premium - np.sum(new_premiums) + bank_account_value - usd_interest_cost + eur_interest_accr * spot_quote.value()\n\nprint(f\"Portfolio value at time t = 1 is: ${new_total_portfolio_value}\")\n\nPortfolio value at time t = 1 is: $202.86605298389892\n\n\nThus the variation from time 0 to time 1 is just about \\(\\$200\\), this confirms that our hedge worked by limiting the variation of the whole portfolio value."
  },
  {
    "objectID": "posts/post-with-code/exotic-book.html",
    "href": "posts/post-with-code/exotic-book.html",
    "title": "Hedging a book of exotic options",
    "section": "",
    "text": "In this notebook, we take on the role of a trader working on an investment bank’s exotic options desk, focusing on FX derivatives. We will explore how such traders hedge their books and how the portfolio’s value and Greek exposures change as the underlying market parameters evolve. To keep things simple, we assume the underlying follows a geometric Brownian motion, with flat term structures for both the volatility surface and the domestic and foreign interest rates. This places us in a Black-Scholes framework (specifically the BS-extended model for FX options, the Garman-Kohlhagen model), described by the following dynamics under the risk-neutral measure:\n\\[\n\\begin{align*}\ndS_t &= (r_d - r_f) S_t \\, dt + \\sigma S_t \\, dW_t^d, \\\\\ndB^d_t &= r_d B^d_t\\, dt, \\\\\ndB^f_t &= r_f B^f_t\\, dt\n\\end{align*}\n\\]\nThe investments banks are said to be on the “sell-side”, which basically means that they facilitate transactions between institutions, and provide access to financial markets. In our case we are manifacturing exotics options for our clients, who are seeking market opportunities. This leaves the trader with a significant exposition, as the bank take the opposite side of client trades. To manage the risk and ensure the bank meet its obligations when options are exercised, the trader must hedge against market movements.\nThe hedging of exotics does not only involves hedging first order greeks (the \\(\\Delta\\) and the \\(\\mathcal{V}\\)), but its involves hedging high order greeks like \\(\\Gamma\\), \\(Vanna\\) (DvolDspot) and \\(Volga\\) (DvegaDvol). Another completixity when hedging exotics option, especially when dealing with binary or barriers, pin risks needs to be taken into account when the barrier is hit.\nThe library we use for option pricing is QuantLib, the largest open-source quantitative finance library available. QuantLib offers a comprehensive suite of tools for modeling, pricing, and risk management of financial derivatives. Its active community and extensive documentation make it a popular choice among both practitioners and researchers in the field."
  },
  {
    "objectID": "posts/post-with-code/exotic-book.html#market-data",
    "href": "posts/post-with-code/exotic-book.html#market-data",
    "title": "Hedging a book of exotic options",
    "section": "Market Data",
    "text": "Market Data\nLet’s assume that we are an USD based desk and we are dealing with EURUSD exotics. The initial market data at time \\(t = 0\\) is the following\n\\[\n\\begin{align*}\n    S_0 &= 1.18 \\\\\n    Date(Today) &= 16/09/2025 \\\\\n    T &= 0.5 \\text{ (time to expiration in years)} \\\\\n    r_d &= 0.045 \\\\\n    r_f &= 0.02 \\\\\n    \\sigma &= 0.13 \\\\\n\\end{align*}\n\\]\n\nEUR_USD = 1.18\nspot_quote = ql.SimpleQuote(EUR_USD)\ntoday = ql.Date(16, ql.September, 2025)\nr_d = 0.045\nr_f = 0.02\nvol_quote = ql.SimpleQuote(0.13)\nspot_handle = ql.QuoteHandle(spot_quote)\nvol_handle = ql.QuoteHandle(vol_quote)\n\ndc = ql.Actual365Fixed()\ncalendar = ql.JointCalendar(ql.Italy(), ql.UnitedStates(ql.UnitedStates.NYSE))\n\nexpiration_date = today + ql.Period(6, ql.Months)\nexpiration_time = dc.yearFraction(today, expiration_date)\ndomestic_rf_handle = ql.YieldTermStructureHandle(ql.FlatForward(today, r_d, dc))\nforeign_rf_handle = ql.YieldTermStructureHandle(ql.FlatForward(today, r_f, dc))\nblack_vol = ql.BlackConstantVol(today, ql.NullCalendar(), vol_handle, dc)\nvol_ts_handle = ql.BlackVolTermStructureHandle(black_vol)\n\n# Setting the global evaluation date\nql.Settings.instance().evaluationDate = today\n\n\neur_dates = [ql.Date(27, ql.August, 2025), ql.Date(27, ql.August, 2026), ql.Date(27, ql.August, 2027)]\neur_dfs = [1.0, 0.98, 0.95]\neur_curve = ql.DiscountCurve(eur_dates, eur_dfs, dc)\neur_curve.enableExtrapolation()\n\nusd_dates = [ql.Date(27, ql.August, 2025), ql.Date(27, ql.August, 2026), ql.Date(27, ql.August, 2027)]\nusd_dfs = [1.0, 0.985, 0.96]\nusd_curve = ql.DiscountCurve(usd_dates, usd_dfs, dc)\nusd_curve.enableExtrapolation()\n\nThe forex option market has a particular way of quoting options, the strike prices are quoted in terms of the Delta of the option: this means that before closing the deal, the strike level is not determined yet in absolute terms. Once the deal is closed, given the level of FX spot rate and the IV agreed upon, the strike will be set at a level yielding the BS Delta the two counterparties were dealing. This way of quoting is smart: it allows us not to worry about small movements of the underlying during the bargaining process, because the absolute strike will be defined only after the agreement on the price, so that the trader is sure to trade an option with given features in terms of exposures both to the underlying asset and to the implied volatility.\nThe most liquid FX optios are usually the 25-\\(\\Delta\\) calls and put and the ATM calls and puts, thus those are going to be our basic hedging instruments and the strikes that we are going to refer to for the exotic in our book.\nHere is an example on how FX volatility are quoted:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(10\\Delta p\\)\n\\(25\\Delta p\\)\n\\(35\\Delta p\\)\nATM\n\\(35\\Delta c\\)\n\\(25\\Delta c\\)\n\\(10\\Delta c\\)\n\n\n\n\n1W\n11.96%\n11.69%\n11.67%\n11.75%\n11.94%\n12.19%\n12.93%\n\n\n2W\n11.81%\n11.54%\n11.52%\n11.60%\n11.79%\n12.04%\n12.78%\n\n\n1M\n11.60%\n11.39%\n11.39%\n11.50%\n11.72%\n11.99%\n12.77%\n\n\n2M\n11.43%\n11.16%\n11.15%\n11.25%\n11.48%\n11.76%\n12.60%\n\n\n3M\n11.22%\n10.92%\n10.90%\n11.00%\n11.23%\n11.52%\n12.39%\n\n\n6M\n11.12%\n10.78%\n10.76%\n10.87%\n11.12%\n11.43%\n12.39%\n\n\n9M\n11.04%\n10.72%\n10.71%\n10.83%\n11.09%\n11.41%\n12.39%\n\n\n1Y\n11.00%\n10.69%\n10.68%\n10.80%\n11.06%\n11.39%\n12.38%\n\n\n2Y\n11.02%\n10.63%\n10.60%\n10.70%\n10.94%\n11.28%\n12.34%\n\n\n\nTo get the strike from the Delta-Vol quote QuantLib comes in handy with a BlackDeltaCalculator that from a given delta (and option type, discount factor, spot value, and delta-vol quote value) it returns the strike associated with it.\n\ncall_barrier_factory = FxBarrierOptionFactory(spot_handle, ql.Option.Call)\nput_barrier_factory = FxBarrierOptionFactory(spot_handle, ql.Option.Put)\nput_vanilla_factory = FxVanillaOptionFactory(spot_handle, expiration_date, ql.Option.Put)\ncall_vanilla_factory = FxVanillaOptionFactory(spot_handle, expiration_date, ql.Option.Call)\ndelta_call_calc = ql.BlackDeltaCalculator(\n    ql.Option.Call, \n    ql.DeltaVolQuote.Spot, \n    EUR_USD, \n    eur_curve.discount(expiration_time), \n    usd_curve.discount(expiration_time), \n    np.sqrt(black_vol.blackVariance(expiration_time, EUR_USD)))\ndelta_put_calc = ql.BlackDeltaCalculator(\n    ql.Option.Put, \n    ql.DeltaVolQuote.Spot, \n    EUR_USD, \n    eur_curve.discount(expiration_time), \n    usd_curve.discount(expiration_time), \n    np.sqrt(black_vol.blackVariance(expiration_time, EUR_USD)))\n\n# Get the strikes equivalent for the 0.25 delta for call and put options\nd25_call_strike = delta_call_calc.strikeFromDelta(0.25)\nd25_put_strike = delta_put_calc.strikeFromDelta(-0.25)\natm_strike = delta_call_calc.atmStrike(ql.DeltaVolQuote.AtmDeltaNeutral)\n\nThe model that extends the Black-Scholes model when dealing with FX options is the Garman-Kohlhagen model, whose dynamics have been defined above. Thus we need to create an instance of the Garman-Kohlhagen process in order to price FX options.\nFor the sake of simplicity we assume that all the options on the book have the same expiration, and again since we are under the Garman-Kohlhagen model the vol curve is flat, thus the vol across the different strikes is the same (unrealistic assumption). Here’s how the trader book is composed of:\n1st Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.30 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 1\nnotional = 1_000_000\nbarrier = 1.30\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_130b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbarrier_1 = BarrierPosition(barrier_25d_130b, notional, NullInstrument())\n\n2nd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$2000000 \\\\\n    \\text{Barrier} &= 1.08 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 2\nnotional = 2_000_000\nbarrier = 1.08\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_108b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbarrier_2 = BarrierPosition(barrier_25d_108b, notional, NullInstrument())\n\n3rd Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Call} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.20 \\\\\n    \\text{Strike} &= 25\\Delta c \\\\\n    \\text{Barrier Type} &= \\text{Up and In}\n\\end{align*}\n\\]\n\n# Barrier 3\nnotional = 1_000_000\nbarrier = 1.20\nbarrier_type = ql.Barrier.UpIn\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_120b = call_barrier_factory.get_option(d25_call_strike, exercise, barrier, barrier_type)\nbackup_vanilla = call_vanilla_factory.get_option(d25_call_strike)\nFxVanillaOptionFactory.assign_analyitcal_price_engine(backup_vanilla, process)\nbarrier_3 = BarrierPosition(barrier_25d_120b, notional, backup_vanilla)\n\n4th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.05 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Down and Out}\n\\end{align*}\n\\]\n\n# Barrier 4\nnotional = 1_000_000\nbarrier = 1.05\nbarrier_type = ql.Barrier.DownOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_105b = put_barrier_factory.get_option(d25_put_strike, exercise, barrier, barrier_type)\nbarrier_4 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n5th Barrier\n\\[\n\\begin{align*}\n    \\text{Option type} &= \\text{Put} \\\\\n    \\text{Notional} &= \\$1000000 \\\\\n    \\text{Barrier} &= 1.25 \\\\\n    \\text{Strike} &= 25\\Delta p \\\\\n    \\text{Barrier Type} &= \\text{Up and Out}\n\\end{align*}\n\\]\n\n# Barrier 5\nnotional = 2_000_000\nbarrier = 1.25\nbarrier_type = ql.Barrier.UpOut\nexercise = ql.EuropeanExercise(expiration_date)\n\nbarrier_25d_105b = put_barrier_factory.get_option(d25_put_strike, exercise, barrier, barrier_type)\nbarrier_5 = BarrierPosition(barrier_25d_105b, notional, NullInstrument())\n\n\nbook: List[BarrierPosition] = [barrier_1, barrier_2, barrier_3, barrier_4, barrier_5]\n\nfor ins in book:\n    FxBarrierOptionFactory.assign_analyitcal_price_engine(ins.instrument, process)\n\nThus the premium of the options will be the following\n\n\n[309.09996820797926,\n 36387.852679406504,\n 18342.987983359482,\n 2064.118402600054,\n 25897.462236607375]\n\n\nSince the AnalyticBarrierEngine in QuantLib doesn’t provide greek calculation functionalities, the simplest method that we can use to calculate the greeks numerically is by using the finite difference method. Let’s the define the basic central differences formulas below, and then specialize them using a partial function application to get the greeks of interest.\nFirst order Finite Difference:\n\\[\nf'(x) = \\frac{f(x + h) - f(x - h)}{2 \\cdot h}\n\\]\nSecond order Finite Difference:\n\\[\nf''(x) = \\frac{f(x + h) - 2f(x) + f(x - h)}{h^2}\n\\]\nCross partial derivative:\n\\[\nf_{xy}(x, y) = \\frac{f(x + h, y + k) - f(x +h, y - k) - f(x - h, y + k) + f(x - h, y - k)}{4hk}\n\\]\n\ndef central_diff(instrument: ql.Instrument, h: float, quote: ql.SimpleQuote) -&gt; float:\n    u0 = quote.value()\n    quote.setValue(u0 + h)\n    P_Plus = instrument.NPV()\n    quote.setValue(u0 - h)\n    P_Minus = instrument.NPV()\n\n    quote.setValue(u0)\n    \n    return (P_Plus - P_Minus) / (2 * h)\n\n\ndef central_diff_2nd(instrument: ql.Instrument, h: float, quote: ql.SimpleQuote) -&gt; float:\n    u0 = quote.value()\n    P = instrument.NPV()\n    quote.setValue(u0 + h)\n    P_Plus = instrument.NPV()\n    quote.setValue(u0 - h)\n    P_Minus = instrument.NPV()\n\n    quote.setValue(u0)\n    \n    return (P_Plus - 2*P + P_Minus) / (h * h)\n\ndef cross_central_diff(instrument: ql.Instrument, h: float, k: float, quote_1: ql.SimpleQuote, quote_2: ql.SimpleQuote) -&gt; float:\n    u1_0 = quote_1.value()\n    u2_0 = quote_2.value()\n    \n    quote_1.setValue(u1_0 + h)\n    quote_2.setValue(u1_0 + k)\n    P_Plus_Plus = instrument.NPV()\n\n    quote_1.setValue(u1_0 + h)\n    quote_2.setValue(u1_0 - k)\n    P_Plus_Minus = instrument.NPV()\n\n    quote_1.setValue(u1_0 - h)\n    quote_2.setValue(u1_0 + k)\n    P_Minus_Plus = instrument.NPV()\n\n    quote_1.setValue(u1_0 - h)\n    quote_2.setValue(u1_0 - k)\n    P_Minus_Minus = instrument.NPV()\n\n    quote_1.setValue(u1_0)\n    quote_2.setValue(u2_0)\n    \n    return (P_Plus_Plus - P_Plus_Minus - P_Minus_Plus + P_Minus_Minus) / (4 * h * k)\n\nFrom that we can easily define the greeks functions:\n\ndelta = partial(central_diff, quote=spot_quote)\nvega = partial(central_diff, quote=vol_quote)\ngamma = partial(central_diff_2nd, quote=spot_quote)\nvolga = partial(central_diff_2nd, quote=vol_quote)\nvanna = partial(cross_central_diff, quote_1=spot_quote, quote_2=vol_quote)"
  },
  {
    "objectID": "posts/post-with-code/exotic-book.html#hedging-the-book",
    "href": "posts/post-with-code/exotic-book.html#hedging-the-book",
    "title": "Hedging a book of exotic options",
    "section": "Hedging the book",
    "text": "Hedging the book\nNow that we have set up the trader portfolio, we need to find the optimal hedge for that portfolio that is going to minimize the sensitivities that we want not be exposed to. Usually a trader sitting in a exotic desk will not just keep low exposure to the classical greeks like \\(\\Delta\\), \\(\\Gamma\\) and \\(\\mathcal{V}\\), but also in some higher order Greeks live DVegaDvol (a.k.a. \\(Volga\\)) and the DVegaDSpot (a.k.a. \\(Vanna\\)).\nThis need comes from the fact that in case of exotics (especially for barrier and binaries) the “barrier” risks needs to be hedged: as spot moves closer to the barrier, vega can spike, that’s vanna risk.\nThe most common way to hedge those greeks in the FX option market is by using simple structure that can be obtained by \\(25 \\Delta\\) calls and puts and ATM calls and puts. Here’s the basic structures that will compose our hedging portfolio:\n\nSpot: to oviously to hedge the \\(\\Delta\\)\nATM straddles: involves buying an ATM vanilla call and ATM vanilla put, this structure provides positive gamma and positive vega\nRR (Risks reversals): involves buying an \\(25 \\Delta\\) vanilla call and sell a \\(25 \\Delta\\) vanilla put, provides a strong vanna exposure (becuase calls and puts respond differently as spot moves)\nButterflies: involves buying an \\(25 \\Delta\\) vanilla call and sell a \\(25 \\Delta\\) vanilla put and selling twice a straddle, provides a strong volga exposure.\n\n\nHedge methodology\nThe way we are going to find the optimal weights of our hedging portfolio is by using the classical parameter hedging methodology. Which mathematically means to set up a linear system where:\nThe exposure vector is:\n\\[\n\\mathbf{E} = \\begin{bmatrix} \\Delta \\\\ \\Gamma \\\\ \\text{Vega} \\\\ \\text{Vanna} \\\\ \\text{Volga} \\end{bmatrix}.\n\\]\nwhich represent the total exposure of our portfolio (the weighted sum of each instrument greek in our exotic portfolio). For each hedge instrument \\(j\\) (spot, ATM straddle, RR, BF), compute its greek vector \\(\\mathbf{h}_j\\). Form the hedge matrix:\n\\[\nH = \\begin{bmatrix} \\mathbf{h}_1 & \\mathbf{h}_2 & \\dots & \\mathbf{h}_n \\end{bmatrix}.\n\\]\nThen solve for weights \\(\\mathbf{x}\\) (position sizes):\n\\[\nH \\mathbf{x} - E  \\approx 0.\n\\]\nIn our case the exposure vector is bigger than the hedging vector \\(x\\), since we only 4 instruments and 5 greeks to hedge. We end up with a linear system with 4 variables and 5 equations, thus there is not an exact solution, but we can find a solution that minimized the sum of residual squares.\nWhen we want to calculate the greeks of our portfolio, we want to do it in meaningful way, thus this requires to us to set the shift operator in a way that makes sense to measure the specific risk of our porfolio. The two main ways that industry professional do that is by using 1% of the spot change and 1% vol change.\n\nspot_change = 0.01 * spot_quote.value() / 2\nvol_change = 0.01 / 2\n\ndelta_book = sum([pos.sensitivity(delta, h=spot_change) for pos in book])\nvega_book = sum([pos.sensitivity(vega, h=vol_change) for pos in book])\nvolga_book = sum([pos.sensitivity(volga, h=vol_change) for pos in book])\ngamma_book = sum([pos.sensitivity(gamma, h=spot_change) for pos in book])\nvanna_book = sum([pos.sensitivity(vanna, h=spot_change, k=vol_change) for pos in book])\n\nThe raw Greek exposition for our book is then the following:\n\n\nBook Delta exposure: 371644.134787602\nBook Gamma exposure: 13330632.102691187\nBook Vega exposure: 1183872.580309415\nBook Volga exposure: 380633.56067277736\nBook Vanna exposure: 190025.47439962075\n\n\nIn FX, Greeks can be confusing, because they depend on the quotation of the currency pair as well as the currency in which they are calculated. Furthermore, premium can be included or excluded, smile-effect can be included or not included, and numerical approximations may further add to the confusion.\nWhat traders use in real life are a “modified version” of the plain greeks:\n\nThe plain \\(\\Delta\\) of a forex option gives the amount of Foreing currency a trader would have to buy in the spot-market to delta-hedge a sold-option. To get the amount of dollars to buy those EURs (in our case) we need to multiply the delta by the current spot value.\nTraders’ \\(\\Gamma\\): where the spot in the finite diff method is varied by 0.5% and then multiplied by 1%, since traders consider the change of delta as spot changes relatively by 1%.\n\n\\[\n\\Gamma^{tr}_t = \\Gamma_t \\frac{S_t}{100}\n\\]\n\nTraders’ \\(\\mathcal{V}\\): A trader will typically consider vega as the change of the USD or EUR value of a derivative contract (or a book of derivatives) assuming a 1% absolute/constant change in volatility.\n\n\\[\n\\frac{V(\\sigma + 0.5\\%) - V(\\sigma - 0.5\\%)}{1\\%} \\cdot 1\\%\n\\]\n\n\nBook Delta exposure: $438540.0790493703\nBook Gamma exposure: $157301.458811756\nBook Vega exposure: $11838.72580309415\nBook Volga exposure: $3806.3356067277737\nBook Vanna exposure: $2242.300597915525\n\n\nAs you might guess the exposition is negative since we are on the sell-side of the trade, thus we need to buy the hedging structures to hedge ourselves from those greeks.\nOur exposure vector \\(E = [ \\Delta, \\Gamma, \\mathcal{V}, Volga, Vanna ]\\) is:\n\n# Greek exposure vector\nE = np.array([delta_book, gamma_book, vega_book, volga_book, vanna_book])\nE\n\narray([  371644.1347876 , 13330632.10269119,  1183872.58030942,\n         380633.56067278,   190025.47439962])\n\n\nFor each of the base instrument (Spot, ATM call, ATM put, \\(25\\Delta\\) call and \\(25\\Delta\\) put) let’s calculate the basic greeks.\n\n# hedge_matrix\nbase_notional = np.float64(1_000_000)\nspot_greeks = np.array([1, 0, 0, 0, 0]) * base_notional\natm_call_greeks = np.array([\n    delta(atm_call, h=spot_change),\n    gamma(atm_call, h=spot_change),\n    vega(atm_call, h=vol_change),\n    volga(atm_call, h=vol_change),\n    vanna(atm_call, h=spot_change, k=vol_change),\n]) * base_notional\natm_put_greeks = np.array([\n    delta(atm_put, h=spot_change),\n    gamma(atm_put, h=spot_change),\n    vega(atm_put, h=vol_change),\n    volga(atm_put, h=vol_change),\n    vanna(atm_put, h=spot_change, k=vol_change),\n]) * base_notional\ndelta25_call_greeks = np.array([\n    delta(delta25_call, h=spot_change),\n    gamma(delta25_call, h=spot_change),\n    vega(delta25_call, h=vol_change),\n    volga(delta25_call, h=vol_change),\n    vanna(delta25_call, h=spot_change, k=vol_change),\n]) * base_notional\ndelta25_put_greeks = np.array([\n    delta(delta25_put, h=spot_change),\n    gamma(delta25_put, h=spot_change),\n    vega(delta25_put, h=vol_change),\n    volga(delta25_put, h=vol_change),\n    vanna(delta25_put, h=spot_change, k=vol_change),\n]) * base_notional\n\nFrom there let’s calculate the greek exposure for the strcutures that we are going to use in out hedging portfolio, and then create our Hedge Matrix:\n\\[\nH = \\left[\n\\begin{array}{c|cccc}\n    & \\text{Spot} & \\text{Straddle} & \\text{RR} & \\text{Butterfly} \\\\\n    \\hline\n    \\Delta   & h_{11} & h_{12} & h_{13} & h_{14} \\\\\n    \\Gamma   & h_{21} & h_{22} & h_{23} & h_{24} \\\\\n    \\text{Vega}   & h_{31} & h_{32} & h_{33} & h_{34} \\\\\n    \\text{Volga}  & h_{41} & h_{42} & h_{43} & h_{44} \\\\\n    \\text{Vanna}  & h_{51} & h_{52} & h_{53} & h_{54} \\\\\n\\end{array}\n\\right]\n\\]\n\n# Let's create the straddle, RR, Butterfly from the base vanilla options\natm_straddle = atm_call_greeks + atm_put_greeks\nrr = delta25_call_greeks - delta25_put_greeks\nbutterfly = delta25_call_greeks + delta25_put_greeks - 2 * atm_straddle\n\n# Hedge Matrix\nH = np.stack([spot_greeks, atm_straddle, rr, butterfly]).T\n\nSince our system have more equations than variables, we must use a least square method (provided by np.linalg.lstsq) to solve it. Least square method minimizes the Euclidian 2-norm $ || E - Hx || $.\n\nx, _, _, _ = np.linalg.lstsq(H, E)\n\nNow that we have a solution let’s see what’s our remaining exposure to each of the choosen hedged greeks. We do that by\n\\[\nH x - E\n\\]\n\nresidual_greeks = (H @ x - E).tolist()\n\nprint(f\"Residual Delta exposure: ${residual_greeks[0] * spot_quote.value()}\")\nprint(f\"Residual Gamma exposure: ${residual_greeks[1] * 0.01 * spot_quote.value()}\")\nprint(f\"Residual Vega exposure: ${residual_greeks[2] * 0.01}\")\nprint(f\"Residual Volga exposure: ${residual_greeks[3] * 0.01}\")\nprint(f\"Residual Vanna exposure: ${residual_greeks[4] * spot_quote.value() * 0.01}\")\n\nResidual Delta exposure: $-2.6100315153598783e-09\nResidual Gamma exposure: $-13.422826034608855\nResidual Vega exposure: $126.72764540341916\nResidual Volga exposure: $0.016476123058237136\nResidual Vanna exposure: $-0.09291220850032404\n\n\nAnother crucial thing when hedging a book is, of course, to measure the P&L from one rebalancing period to another. Let’s then calculate the value of the various components of our hedging portfolio. We have the the P&L from time \\(t\\) is calculated as:\n\\[\nP\\&L_{t \\rightarrow t + 1} = (V_{t + 1}^{book} + V_{t + 1}^{hedge} + C_{t + 1}) - (V_{t}^{book} + V_{t}^{hedge} + C_{t})\n\\]\nwhere:\n\n\\(V_{t}^{book}\\) is the value of our book at time \\(t\\), which is the sum of the premiums that we’ve been collected\n\\(V_{t}^{hedge}\\) is the value of the hedging portfolio, the sum of the premium of the structures that we have bought to hedge our from the various sensistivies\n\\(C_t\\) the cash/bank account of our portfolio which includes financing of cash and trade cashflows\n\nA shorter way to express the P&L, is just by considering the variation of the value of the book + the variation of the value of the hedges + cost of borrowing + interest accrued:\n\\[\nP\\&L_{t \\rightarrow t + 1} = \\delta V_{t, t + 1}^{book} + \\delta V_{t, t + 1}^{hedge} + \\text{cost of borrowing} + \\text{interest accrued}\n\\]\nsince the rebalancing of the hedges of the bank account happend at the end of trading day.\n\nspot_premium_eur = x[0] * base_notional\nspot_premium_usd = x[0] * base_notional * spot_quote.value()\natm_straddle_premium = atm_call.NPV() + atm_put.NPV() * base_notional * x[1]\nrr_premium = delta25_call.NPV() - delta25_put.NPV() * base_notional * x[2]\nbutterfly_premium = (delta25_call.NPV() + delta25_put.NPV() - 2 * (atm_call.NPV() + atm_put.NPV())) * x[3] * base_notional\n\nThe usd borrowed (which is the sum of the premiums of or hedging instrument) is crucial for use to calculate the interest accrued for borrowing the usd dollars to buy the hedging structures.\n\nhedging_str_premium = atm_straddle_premium + rr_premium + butterfly_premium + spot_premium_usd\nhedging_str_premium\n\nnp.float64(4182631.052146415)\n\n\nThus the value of the cash at time \\(t = 0\\) is the equal to all the cash that we’ve borrowed to build the hedging structures plus the premiums that we’ve been collected from selling the exotics options\n\nbank_account_value = - hedging_str_premium + np.sum(premiums)\nbank_account_value\n\nnp.float64(-4099629.5308762337)\n\n\n\nport_value = [hedging_str_premium - np.sum(premiums) + bank_account_value]\n\nprint(f\"The portfolio value at time t = 0 is {port_value[0]}\")\n\nThe portfolio value at time t = 0 is 0.0"
  },
  {
    "objectID": "posts/post-with-code/exotic-book.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "href": "posts/post-with-code/exotic-book.html#changes-of-the-hedging-portfolio-with-the-changes-of-the-market-conditions",
    "title": "Hedging a book of exotic options",
    "section": "Changes of the hedging portfolio with the changes of the market conditions",
    "text": "Changes of the hedging portfolio with the changes of the market conditions\nNow that we have setup our hedging portfolio see verify how its will change as the spot and vol change. Let’s assume that in a week period the spot went go down by 300 pips and the vol went up by \\(1\\%\\).\n\nspot_quote.setValue(1.15)\nvol_quote.setValue(0.14)\nql.Settings.instance().evaluationDate = today + ql.Period(7, ql.Days)\n\n\nnew_premiums = [pos.NPV() for pos in book]\n\nWith the new spot and vol let’s recalculate the book exposure\n\ndelta_book = sum([pos.sensitivity(delta, h=spot_change) for pos in book])\nvega_book = sum([pos.sensitivity(vega, h=vol_change) for pos in book])\nvolga_book = sum([pos.sensitivity(volga, h=vol_change) for pos in book])\ngamma_book = sum([pos.sensitivity(gamma, h=spot_change) for pos in book])\nvanna_book = sum([pos.sensitivity(vanna, h=spot_change, k=vol_change) for pos in book])\n\n# new Exposure vector\nE = np.array([delta_book, gamma_book, vega_book, volga_book, vanna_book])\n\n\n\nBook Delta exposure: $16549.207988699432\nBook Gamma exposure: $138778.80052508457\nBook Vega exposure: $11096.72161278602\nBook Volga exposure: $560.5276947207037\nBook Vanna exposure: $2416.5207043533637\n\n\nAs before let’s recalculate the greeks for the basic trading instruments, and then combine to obtain the greeks for the structures used in the hedging portfolio.\n\n# hedge_matrix\nbase_notional = np.float64(1_000_000)\nspot_greeks = np.array([1, 0, 0, 0, 0]) * base_notional\natm_call_greeks = np.array([\n    delta(atm_call, h=spot_change),\n    gamma(atm_call, h=spot_change),\n    vega(atm_call, h=vol_change),\n    volga(atm_call, h=vol_change),\n    vanna(atm_call, h=spot_change, k=vol_change),\n]) * base_notional\natm_put_greeks = np.array([\n    delta(atm_put, h=spot_change),\n    gamma(atm_put, h=spot_change),\n    vega(atm_put, h=vol_change),\n    volga(atm_put, h=vol_change),\n    vanna(atm_put, h=spot_change, k=vol_change),\n]) * base_notional\ndelta25_call_greeks = np.array([\n    delta(delta25_call, h=spot_change),\n    gamma(delta25_call, h=spot_change),\n    vega(delta25_call, h=vol_change),\n    volga(delta25_call, h=vol_change),\n    vanna(delta25_call, h=spot_change, k=vol_change),\n]) * base_notional\ndelta25_put_greeks = np.array([\n    delta(delta25_put, h=spot_change),\n    gamma(delta25_put, h=spot_change),\n    vega(delta25_put, h=vol_change),\n    volga(delta25_put, h=vol_change),\n    vanna(delta25_put, h=spot_change, k=vol_change),\n]) * base_notional\n\n\n# Let's create the straddle, RR, Butterfly from the base vanilla options\natm_straddle = atm_call_greeks + atm_put_greeks\nrr = delta25_call_greeks - delta25_put_greeks\nbutterfly = delta25_call_greeks + delta25_put_greeks - 2 * atm_straddle\n\n# Hedge Matrix\nH = np.stack([spot_greeks, atm_straddle, rr, butterfly]).T\n\nThe esposure of our hedging portfolio is now is:\n\n# New exposure of the hedging portfolio\nexposure = (H @ x - E).tolist()\n\nprint(f\"Residual Delta exposure: ${exposure[0] * spot_quote.value()}\")\nprint(f\"Residual Gamma exposure: ${exposure[1] * 0.01 * spot_quote.value()}\")\nprint(f\"Residual Vega exposure: ${exposure[2] * 0.01}\")\nprint(f\"Residual Volga exposure: ${exposure[3] * 0.01}\")\nprint(f\"Residual Vanna exposure: ${exposure[4] * 0.01 * spot_quote.value()}\")\n\nResidual Delta exposure: $-348789.7260608019\nResidual Gamma exposure: $73758.42210270112\nResidual Vega exposure: $5879.026689021433\nResidual Volga exposure: $-54024.14332019365\nResidual Vanna exposure: $117.87655605534354\n\n\nTo calculate the P&L from time t to t+1 we need to calculate the change of the value of the hedging portfolio as well\n\nspot_premium_usd = x[0] * base_notional * spot_quote.value()\natm_straddle_premium = atm_call.NPV() + atm_put.NPV() * base_notional * x[1]\nrr_premium = delta25_call.NPV() - delta25_put.NPV() * base_notional * x[2]\nbutterfly_premium = (delta25_call.NPV() + delta25_put.NPV() - 2 * (atm_call.NPV() + atm_put.NPV())) * x[3] * base_notional\nnew_hedging_str_premium = atm_straddle_premium + rr_premium + butterfly_premium + spot_premium_usd\n\n\ndt = dc.yearFraction(today, today + ql.Period(7, ql.Days))\nusd_interest_cost = hedging_str_premium * r_d * dt\neur_interest_accr = spot_premium_eur * r_f * dt\nnew_total_portfolio_value = new_hedging_str_premium - np.sum(new_premiums) + bank_account_value - usd_interest_cost + eur_interest_accr * spot_quote.value()\n\nprint(f\"Portfolio value at time t = 1 is: ${new_total_portfolio_value}\")\n\nPortfolio value at time t = 1 is: $-8014.640804257949\n\n\n\n\nThe P&L after a week is: $-8014.640804257949\n\n\nIf we want to reduce our exposure and bring it back to a lower one, we need to recalculate the optiomal hedging weight for our hedging portfolio as before:\n\nx_new, _, _, _ = np.linalg.lstsq(H, E)\n\nThis how our hedging portfolio has to change:\n\nx_new - x\n\narray([-0.33252725,  3.27195222,  0.99407244,  3.52132318])\n\n\nThe residual greek exposure after the rebalancing is:\n\n\nResidual Delta exposure: $-4.2255123844370243e-10\nResidual Gamma exposure: $1.7120357189066706\nResidual Vega exposure: $-16.21605768425856\nResidual Volga exposure: $-0.0021280367333383764\nResidual Vanna exposure: $0.014062687186218682"
  }
]